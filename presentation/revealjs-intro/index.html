<!doctype html>
<html lang="de">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Telekom Architecture Training</title>

		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/reset.css">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/reveal.css">
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/theme/white.css" id="theme">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- 1. Title slide -->
				<section>
					<div class="title-slide">
						<img src="img/VanillaCore_Vertical.png" alt="CORE Logo" class="logo">
						<h1>Design Patterns Workshop</h1>
						<h2 style="font-size: 2em; color: #666; font-weight: 300; margin-top: 20px;">Telekom Architecture Training</h2>
					</div>
					<aside class="notes">
						Willkommen zum Design Patterns Workshop. Dieser Workshop ist Teil des Telekom Architecture Trainings und fokussiert sich auf bewährte Entwurfsmuster in der Softwareentwicklung.
					</aside>
				</section>

				<!-- 2. Section slide -->
				<section>
					<div class="section-slide">
						<img src="img/VanillaCore_Vertical.png" alt="CORE Logo" class="logo">
						<h1>Workshop Agenda</h1>
					</div>
					<aside class="notes">
						In diesem Abschnitt werden wir die Agenda des Workshops durchgehen und einen Überblick über die zu behandelnden Themen geben.
					</aside>
				</section>

				<!-- 3. Single column with intro text (non-bullet paragraphs) -->
				<section class="single-column content-slide">
						<img src="img/VanillaCore_Square.png" alt="CORE Logo" class="logo-corner">
						<h2>Design Patterns in der Softwareentwicklung</h2>
						<p>Design Patterns sind bewährte Lösungsschablonen für wiederkehrende Entwurfsprobleme in der Softwareentwicklung. Sie beschreiben die Kommunikation zwischen Objekten und Klassen, die angepasst werden, um ein allgemeines Entwurfsproblem in einem bestimmten Kontext zu lösen.</p>
						
						<p class="fragment" data-fragment-index="1">Jedes Pattern beschreibt ein Problem, das immer wieder in unserer Umgebung auftritt, und dann den Kern der Lösung zu diesem Problem, auf eine Weise, dass Sie diese Lösung millionenfach anwenden können, ohne sie jemals auf die gleiche Weise zu implementieren.</p>
						
						<p class="fragment" data-fragment-index="2">Patterns fördern die Wiederverwendung von bewährtem Design und Architekturen. Sie schaffen eine gemeinsame Sprache für Entwickler und machen komplexe Designentscheidungen für alle Teammitglieder nachvollziehbar.</p>
					<aside class="notes">
						Diese Folie führt das Konzept der Design Patterns ein. Wir erklären, was Patterns sind und warum sie wichtig sind. Die Definition stammt aus dem berühmten "Gang of Four" Buch, dem Grundlagenwerk für Design Patterns.
					</aside>
				</section>

				<!-- 4. Single column with bullet points -->
				<section class="single-column content-slide">
						<img src="img/VanillaCore_Square.png" alt="CORE Logo" class="logo-corner">
						<h2>Workshop Ziele</h2>
						<ul>
							<li>Design Patterns verstehen und anwenden</li>
							<li class="fragment" data-fragment-index="1">Bewährte Lösungsmuster für häufige Probleme erkennen</li>
							<li class="fragment" data-fragment-index="2">Code-Qualität und Wartbarkeit verbessern</li>
							<li class="fragment" data-fragment-index="3">Kommunikation zwischen Entwicklern fördern</li>
							<li class="fragment" data-fragment-index="4">Praktische Anwendung in realen Projekten</li>
						</ul>
					<aside class="notes">
						Diese Folie zeigt die Hauptziele unseres Design Patterns Workshops. Wir fokussieren uns darauf, wie Patterns dabei helfen, besseren und wartbareren Code zu schreiben.
					</aside>
				</section>

				<!-- 5. Two column layout with enhanced fragments -->
				<section class="two-columns content-slide">
						<img src="img/VanillaCore_Square.png" alt="CORE Logo" class="logo-corner">
						<h2>Patterns Übersicht</h2>
						<div class="columns-container">
							<div class="column">
								<h3>Erstellungsmuster:</h3>
								<ul>
									<li>Singleton</li>
									<li class="fragment fade-up" data-fragment-index="1">Factory Method</li>
									<li class="fragment fade-up" data-fragment-index="2">Abstract Factory</li>
									<li class="fragment fade-up" data-fragment-index="3">Builder</li>
									<li class="fragment fade-up" data-fragment-index="4">Prototype</li>
								</ul>
							</div>
							<div class="column fragment" data-fragment-index="5">
								<h3>Strukturmuster:</h3>
								<ul>
									<li>Adapter</li>
									<li class="fragment fade-up" data-fragment-index="6">Decorator</li>
									<li class="fragment fade-up" data-fragment-index="7">Facade</li>
									<li class="fragment fade-up" data-fragment-index="8">Composite</li>
									<li class="fragment fade-up" data-fragment-index="9">Proxy</li>
								</ul>
							</div>
						</div>
					<aside class="notes">
						Hier sehen wir eine Übersicht der wichtigsten Design Patterns, die wir in diesem Workshop behandeln werden. Zunächst erscheinen nur die Überschriften und ersten Einträge, dann werden die Patterns nach und nach sichtbar. Links die Creational Patterns für Objekterzeugung, rechts die Structural Patterns für Objektkomposition.
					</aside>
				</section>

				<!-- 6. Half-picture slide -->
				<section class="half-picture content-slide">
						<div class="text-content">
							<h2>Praxisbeispiele</h2>
							<p>Patterns in der Praxis:</p>
							<ul>
								<li>MVC Architecture Pattern</li>
								<li class="fragment" data-fragment-index="1">Dependency Injection</li>
								<li class="fragment" data-fragment-index="2">Repository Pattern</li>
								<li class="fragment" data-fragment-index="3">Observer für Event Handling</li>
								<li class="fragment" data-fragment-index="4">Strategy für Algorithmus-Auswahl</li>
								<li class="fragment" data-fragment-index="5">Command für Undo-Funktionalität</li>
								<li class="fragment" data-fragment-index="6">Template Method für Workflows</li>
							</ul>
						</div>
						<div class="image-content">
							<img src="img/VanillaCore_Vertical.png" alt="Code architecture visualization" class="half-image">
						</div>
					<aside class="notes">
						Diese Folie zeigt konkrete Beispiele, wie Design Patterns in realen Softwareprojekten eingesetzt werden. Jedes Pattern löst spezifische Probleme in der Architektur und im Design.
					</aside>
				</section>

				<!-- 7. Code Sample - Embedded (inline with text) -->
				<section class="code-slide code-embedded content-slide">
					<img src="img/VanillaCore_Square.png" alt="CORE Logo" class="logo-corner">
					<h2>Singleton Pattern</h2>
					<div class="code-embedded">
						<div class="text-section">
							<p>Das Singleton Pattern stellt sicher, dass eine Klasse nur eine Instanz hat und bietet einen globalen Zugriffspunkt darauf.</p>
							<ul>
								<li>Zentrale Ressourcenverwaltung</li>
								<li class="fragment" data-fragment-index="1">Thread-sichere Implementierung</li>
								<li class="fragment" data-fragment-index="2">Lazy Loading Unterstützung</li>
								<li class="fragment" data-fragment-index="3">Einfache <code>getInstance()</code> Methode</li>
							</ul>
						</div>
						<div class="code-section">
							<pre><code class="javascript" data-trim data-line-numbers>
// Singleton Pattern in JavaScript
class DatabaseConnection {
  static instance = null;
  
  constructor() {
    if (DatabaseConnection.instance) {
      return DatabaseConnection.instance;
    }
    
    this.connection = null;
    this.isConnected = false;
    DatabaseConnection.instance = this;
  }
  
  static getInstance() {
    if (!this.instance) {
      this.instance = new DatabaseConnection();
    }
    return this.instance;
  }
  
  connect() {
    if (!this.isConnected) {
      this.connection = createConnection();
      this.isConnected = true;
    }
    return this.connection;
  }
}

// Verwendung
const db1 = DatabaseConnection.getInstance();
const db2 = DatabaseConnection.getInstance();
console.log(db1 === db2); // true
							</code></pre>
						</div>
					</div>
					<aside class="notes">
						Das Singleton Pattern ist eines der am häufigsten verwendeten Design Patterns. Es eignet sich besonders für Datenbankverbindungen, Logger oder Konfigurationsobjekte, wo nur eine Instanz existieren soll.
					</aside>
				</section>

				<!-- 8. Code Sample - Standalone (full slide) -->
				<section class="code-slide code-standalone content-slide">
					<img src="img/VanillaCore_Square.png" alt="CORE Logo" class="logo-corner">
					<div class="code-standalone">
						<h2>Factory Method Pattern</h2>
						<pre><code class="java" data-trim data-line-numbers>
// Factory Method Pattern in Java
public abstract class NotificationFactory {
    
    // Factory Method
    public abstract Notification createNotification();
    
    // Template Method
    public void processNotification(String message) {
        Notification notification = createNotification();
        notification.setMessage(message);
        notification.send();
        notification.log();
    }
}

public class EmailNotificationFactory extends NotificationFactory {
    @Override
    public Notification createNotification() {
        return new EmailNotification();
    }
}

public class SMSNotificationFactory extends NotificationFactory {
    @Override
    public Notification createNotification() {
        return new SMSNotification();
    }
}

// Interface für alle Notification-Typen
public interface Notification {
    void setMessage(String message);
    void send();
    void log();
}

// Verwendung
NotificationFactory emailFactory = new EmailNotificationFactory();
emailFactory.processNotification("Willkommen zum Training!");

NotificationFactory smsFactory = new SMSNotificationFactory();
smsFactory.processNotification("Training beginnt in 5 Minuten");
						</code></pre>
						<p style="margin-top: 2vh; color: #666; font-style: italic;">
							Factory Method entkoppelt die Objekterzeugung vom Client-Code
						</p>
					</div>
					<aside class="notes">
						Das Factory Method Pattern ist ein Creational Pattern, das eine Schnittstelle für die Erzeugung von Objekten definiert, aber den Subklassen die Entscheidung überlässt, welche Klasse instanziiert werden soll. Sehr nützlich für Plugin-Architekturen.
					</aside>
				</section>

				<!-- 9. Code Sample - Observer Pattern with inline code -->
				<section class="code-slide code-embedded content-slide">
					<img src="img/VanillaCore_Square.png" alt="CORE Logo" class="logo-corner">
					<h2>Observer Pattern</h2>
					<div class="code-embedded">
						<div class="text-section">
							<p>Das Observer Pattern definiert eine Abhängigkeit zwischen Objekten, sodass bei Änderung eines Objekts alle abhängigen Objekte automatisch benachrichtigt werden.</p>
							<ul>
								<li>Lose Kopplung zwischen <code>Subject</code> und <code>Observer</code></li>
								<li class="fragment" data-fragment-index="1">Event-driven Architektur</li>
								<li class="fragment" data-fragment-index="2">Unterstützung für <code>subscribe()</code> und <code>unsubscribe()</code></li>
								<li class="fragment" data-fragment-index="3">Automatische Benachrichtigungen via <code>notify()</code></li>
							</ul>
							<p class="fragment" data-fragment-index="4" style="margin-top: 2vh; font-style: italic; color: #666;">
								Ideal für GUI-Events, Model-View-Architekturen und Messaging-Systeme.
							</p>
						</div>
						<div class="code-section">
							<!-- Fragment 1: Subject class constructor (lines 1-5) -->
							<pre class="fragment" data-fragment-index="0"><code class="javascript" data-trim data-line-numbers="1-5">
// Observer Pattern Implementation
class Subject {
  constructor() {
    this.observers = [];
  }
							</code></pre>
							
							<!-- Fragment 2: Subject class methods (lines 1-15) -->
							<pre class="fragment" data-fragment-index="1"><code class="javascript" data-trim data-line-numbers="1-15">
// Observer Pattern Implementation
class Subject {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
  }
  
  unsubscribe(observer) {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }
							</code></pre>
							
							<!-- Fragment 3: Complete Subject + Observer classes (lines 1-25) -->
							<pre class="fragment" data-fragment-index="2"><code class="javascript" data-trim data-line-numbers="1-25">
// Observer Pattern Implementation
class Subject {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
  }
  
  unsubscribe(observer) {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }
  
  notify(data) {
    this.observers.forEach(observer => {
      observer.update(data);
    });
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }
  
  update(data) {
    console.log(`${this.name} received:`, data);
  }
}
							</code></pre>
							
							<!-- Fragment 4: Complete implementation with usage (lines 1-35) -->
							<pre class="fragment" data-fragment-index="3"><code class="javascript" data-trim data-line-numbers>
// Observer Pattern Implementation
class Subject {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
  }
  
  unsubscribe(observer) {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }
  
  notify(data) {
    this.observers.forEach(observer => {
      observer.update(data);
    });
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }
  
  update(data) {
    console.log(`${this.name} received:`, data);
  }
}

// Verwendung
const newsPublisher = new Subject();
const subscriber1 = new Observer("Email Service");
const subscriber2 = new Observer("Push Notification");

newsPublisher.subscribe(subscriber1);
newsPublisher.subscribe(subscriber2);
newsPublisher.notify("Breaking: New Design Pattern!");
							</code></pre>
						</div>
					</div>
					<aside class="notes">
						Das Observer Pattern ist fundamental für event-driven Programming. Es findet sich in fast allen modernen Frameworks wieder - von DOM Events in JavaScript bis zu Reactive Programming mit RxJS oder Spring's ApplicationEvent System.
					</aside>
				</section>

				<!-- 10. Full-picture slide -->
				<section class="full-picture">
					<div class="placeholder-image warehouse" aria-label="Software architecture blueprint"></div>
					<div class="text-overlay">
						<h2>Bessere Software</h2>
						<p>Durch bewährte Patterns</p>
					</div>
					<aside class="notes">
						Design Patterns helfen uns dabei, bessere Software zu entwickeln. Sie bieten bewährte Lösungen für wiederkehrende Probleme und verbessern die Kommunikation zwischen Entwicklern.
					</aside>
				</section>
			</div>
		</div>

		<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/reveal.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/plugin/notes/notes.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/plugin/markdown/markdown.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/plugin/highlight/highlight.js"></script>
		<script src="js/config.js"></script>
	</body>
</html>